"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgJestCompiler = void 0;
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const ts_jest_1 = require("ts-jest");
const jit_transform_1 = require("../transformers/jit_transform");
const replace_resources_1 = require("../transformers/replace-resources");
class NgJestCompiler extends ts_jest_1.TsCompiler {
    constructor(configSet, jestCacheFS) {
        super(configSet, jestCacheFS);
        this.configSet = configSet;
        this.jestCacheFS = jestCacheFS;
        this._logger.debug('created NgJestCompiler');
    }
    _transpileOutput(fileContent, filePath) {
        var _a;
        const diagnostics = [];
        const compilerOptions = Object.assign({}, this._compilerOptions);
        const options = compilerOptions
            ?
                this._ts.fixupCompilerOptions(compilerOptions, diagnostics)
            : {};
        const defaultOptions = this._ts.getDefaultCompilerOptions();
        for (const key in defaultOptions) {
            if (Object.prototype.hasOwnProperty.call(defaultOptions, key) && options[key] === undefined) {
                options[key] = defaultOptions[key];
            }
        }
        for (const option of this._ts.transpileOptionValueCompilerOptions) {
            options[option.name] = option.transpileOptionValue;
        }
        options.suppressOutputPathCheck = true;
        options.allowNonTsExtensions = true;
        const sourceFile = this._ts.createSourceFile(filePath, fileContent, (_a = options.target) !== null && _a !== void 0 ? _a : this._ts.ScriptTarget.Latest);
        let outputText;
        let sourceMapText;
        const compilerHost = {
            getSourceFile: (fileName) => {
                return node_path_1.default.normalize(fileName) === node_path_1.default.normalize(filePath) ? sourceFile : undefined;
            },
            writeFile: (name, text) => {
                if (node_path_1.default.extname(name) === '.map') {
                    sourceMapText = text;
                }
                else {
                    outputText = text;
                }
            },
            getDefaultLibFileName: () => 'lib.d.ts',
            useCaseSensitiveFileNames: () => false,
            getCanonicalFileName: (fileName) => fileName,
            getCurrentDirectory: () => '',
            getNewLine: () => node_os_1.default.EOL,
            fileExists: (fileName) => {
                return node_path_1.default.normalize(fileName) === node_path_1.default.normalize(filePath);
            },
            readFile: () => '',
            directoryExists: () => true,
            getDirectories: () => [],
        };
        this.program = this._ts.createProgram([filePath], options, compilerHost);
        this.program.emit(undefined, undefined, undefined, undefined, this._makeTransformers(this.configSet.resolvedTransformers));
        return { outputText: outputText !== null && outputText !== void 0 ? outputText : '', diagnostics, sourceMapText };
    }
    _makeTransformers(customTransformers) {
        const program = this.program;
        return Object.assign(Object.assign(Object.assign({}, super._makeTransformers(customTransformers).after), super._makeTransformers(customTransformers).afterDeclarations), { before: [
                ...customTransformers.before.map((beforeTransformer) => beforeTransformer.factory(this, beforeTransformer.options)),
                (0, replace_resources_1.replaceResources)(program),
                (0, jit_transform_1.angularJitApplicationTransform)(program),
            ] });
    }
}
exports.NgJestCompiler = NgJestCompiler;
